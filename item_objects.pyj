import model_objects
import game_exceptions

DIRDXY = {
    'N': [ 0, -1],
    'S': [ 0,  1],
    'E': [ 1,  0],
    'W': [-1,  0]
}
TURN_DICT = {
    'N': {
        'L': 'W',
        'R': 'E',
        'F': 'N',
        'B': 'S'
    },
    'S': {
        'L': 'E',
        'R': 'W',
        'F': 'S',
        'B': 'N'
    },
    'W': {
        'L': 'S',
        'R': 'N',
        'F': 'W',
        'B': 'E'
    },
    'E': {
        'L': 'N',
        'R': 'S',
        'F': 'E',
        'B': 'W'
    }
}

class Item(GameObject):
    def __init__(self):
        self.avoid_list = []
        self.unenterable = []
        self.push_list = []
        self.items = {}
        self.immunities = []
        self.can_push_on_walls = False
        
        #Considered saving the index, but that would require a lot of work
        # to keep updated.  
        self.is_slipping = False

    def check_map_bound(self, new_x, new_y):
        #check if the new position is in a map
        if new_x > (LEVELSIZE-1):
            return False
        elif new_x < 0:
            return False
        if new_y > (LEVELSIZE-1):
            return False
        elif new_y < 0:
            return False

        return True
        
    def valid_move(self, start_x, start_y, dx, dy, map, items, game_engine, slip_ind):
        """
        Move an item from start_x, start_y by dx, dy.
        Note that it does not update the sliplist.  Note that monsters cannot
        try and move when on the sliplist 
        """
        #Check the change is in bounds
        new_x = start_x + dx
        new_y = start_y + dy

        valid_move = self.check_map_bound(new_x, new_y)
        if not valid_move:
            return False, start_x, start_y
        
        #see what direction the map wants the player to move
        # leavable checks if the new position is enterable
        curr_floor = map[start_x][start_y]
        valid_move = curr_floor.leavable(start_x, start_y, dx, dy,
                                         map, items, game_engine)
        
        if not valid_move:
            return False, start_x, start_y
        
        #See if this creature can enter this type of flooring
        dest_floor = map[new_x][new_y]
        for unenterabe_class in self.unenterable:
            if dest_floor instanceof unenterabe_class:
                return False, start_x, start_y
        
        neighbors_ok = self.move_neighbors(new_x, new_y, dx, dy, map, items, game_engine)
        if neighbors_ok:
            game_over_msg = self.step_on_item(items[new_x][new_y])
            if game_over_msg:
                raise PlayerKilled(game_over_msg)
            items[new_x][new_y] = self
            items[start_x][start_y] = None
            new_floor = map[new_x][new_y]
            is_slippery = new_floor.slip_item(self)
            if is_slippery:
                s_dx, s_dy = new_floor.get_slip_dir(dx, dy)
                if slip_ind == None:
                    self.add_to_sliplist(game_engine, slip_ind, new_x, new_y, s_dx, s_dy)
                else:
                    self.update_sliplist(game_engine, slip_ind, new_x, new_y, s_dx, s_dy)
            elif slip_ind != None:
                self.remove_from_sliplist(game_engine, slip_ind)
            map[new_x][new_y].enter(game_engine, new_x, new_y, dx, dy, self)
            return True, new_x, new_y
        else:
            #TODO: Remove from the sliplist
            return False, start_x, start_y


    def move_neighbors(self, new_x, new_y, dx, dy, map, items, game_engine):
        #if there are no item in the way, the move is allowed
        if not items[new_x][new_y]:
            return True
        
        #see if the items can interact
        dest_item = items[new_x][new_y]
        interactive = True
        for untouchable_class in self.avoid_list:
            if dest_item instanceof untouchable_class:
                interactive = False
                break

        if not interactive:
            return False

        #if dest_item.is_slipping
        #find the slip_ind
        slip_ind = None

        pushable = False
        for merge_class in self.push_list:
            if isinstance(dest_item, merge_class):
                pushable = True
                break

        if pushable:
            valid_move = dest_item.valid_move(new_x, new_y, dx, dy, map, items, game_engine, slip_ind)[0]
            return valid_move
        return True
    
    def step_on_item(self, target_item):
        return None

    def add_inventory(self, item_name, item):
        console.log('Not Implemented')
        return
    
    def check_inventory(self, item_name, count):
        console.log('Not Implemented')
        return False
    
    def use_item(self, item_name):
        console.log('Not Implemented')
        return
    
    def is_safe(type, item):
        console.log('Not Implemented')
        return False
    
    def burn(self, game_engine, pos_x, pos_y):
        console.log('Not Implemented')
        return
            
    def drown(self, game_engine, pos_x, pos_y):
        console.log('Not Implemented')
        return
        
    def is_safe(self, dmg_type, item):
        if self.immunities.indexOf(dmg_type) >= 0:
            return True
        elif self.check_inventory(item, 1):
            return True
        else:
            return False

    def update_sliplist(self, game_engine, index, pos_x, pos_y, dx, dy):
        self.is_slipping = True
        game_engine.slip_list[index] = (pos_x, pos_y, dx, dy)

    def add_to_sliplist(self, game_engine, index, pos_x, pos_y, dx, dy):
        """
        if index is None, 
        """
        self.is_slipping = True
        game_engine.slip_list.push((pos_x, pos_y, dx, dy))

    def remove_from_sliplist(self, game_engine, index):
        game_engine.slip_list.splice(index, 1)
        self.is_slipping = False

    def kill(self, msg):
        #By default do nothing
        return

class Block(Item):
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img
        self.img = images[type_index]
        self.is_slipping = False

    def step_on_item(self, target_item):
        if (target_item instanceof Player):
            return "block crushed player"
        return None
        

    def burn(self, game_engine, pos_x, pos_y):
        #do nothing blocks are not affected by fire
        return
    
    def drown(self, game_engine, pos_x, pos_y):
        #this drowns the block - makes dirt
        game_engine.map[pos_x][pos_y] = object_generator(11, game_engine.images)
        game_engine.items[pos_x][pos_y] = None


class Creature(Item):
    def __init__(self):
        pass
    
    def add_inventory(self, item_name, item):
        item_count = self.items[item_name]
        if type(item_count) is "undefined":
            self.items[item_name] = 0
        
        self.items[item_name] += 1
    
    def check_inventory(self, item_name, count):
        item_count = self.items[item_name]
        has_items = False
        if type(item_count) is not "undefined" and \
                self.items[item_name] >= count:
            has_items = True
        return has_items
    
    def use_item(self, item_name):
        self.items[item_name] -= 1
    

    def burn(self, game_engine, pos_x, pos_y):
        if not self.is_safe('FIRE', 'INV_FIREBOOTS'):
            #kill the unit
            game_engine.items[pos_x][pos_y] = None
            
    def drown(self, game_engine, pos_x, pos_y):
        if not self.is_safe('WATER', 'INV_FLIPPERS'):
            #kill the unit
            game_engine.items[pos_x][pos_y] = None
            raise MonsterKilled('drowned')

class Player(Creature):
    """
    #51    Drowning Chip                       0    0
    #52    Burned Chip                         0    0
    #53    Burned Chip(2)                      0    0
    #57    Chip in Exit - end game             0    0
    #60    Chip Swimming (N)                   1    0
    #61    Chip Swimming (W)                   1    0
    #62    Chip Swimming (S)                   1    0
    #63    Chip Swimming (E)                   1    0
    #108    Chip (N)                          1    1
    #109    Chip (W)                          1    1
    #110    Chip (S) (Always used)            1    1
    #111    Chip (E)                          1    1
    """
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img
        self.img = images[type_index]
        self.push_list = [Block]
        self.avoid_list = []
        self.can_push_on_walls = True
        self.items = {}
        self.is_slipping = False

    def valid_move(self, start_x, start_y, dx, dy, map, items, game_engine, slip_ind):
        if slip_ind == None and self.is_slipping:
            #Player is always at slipind 0
            slip_ind = 0
        is_valid, new_x, new_y = Item.valid_move(self, start_x, start_y, dx, dy, map, items, game_engine, slip_ind)

        game_engine.x = new_x
        game_engine.y = new_y
        return is_valid, new_x, new_y

    def set_inventory_icon(self, item_name, item):
        """
        Only set the item if the item_count is non-zero
        """
        if item and self.items[item_name] > 0:
            #this is a key, strip the KEY_ portion of the string and lowercase the rest
            key_name = item_name.toLowerCase()
            key_div = document.getElementById(key_name)
            key_div.style.backgroundImage = 'url(' + item.img.src + ')'
        elif self.items[item_name] == 0:
            key_name = item_name.toLowerCase()
            key_div = document.getElementById(key_name)
            key_div.style.backgroundImage = ''

    def add_inventory(self, item_name, item):
        Creature.add_inventory(self, item_name, item)
        
        #the UI shows user keys
        #Note: this [0:4] works in JS but not Python
        if item_name[:4] == 'KEY_' or item_name[:4] == 'INV_':
            self.set_inventory_icon(item_name, item)
        
        #The UI also shows chips left
        pass
        
    def use_item(self, item_name):
        Creature.use_item(self, item_name)
        
        if item_name[:4] == 'KEY_' or item_name[:4] == 'INV_':
            self.set_inventory_icon(item_name, null)

    def burn(self, game_engine, pos_x, pos_y):
        if not self.is_safe('FIRE', 'INV_FIREBOOTS'):
            #kill the unit
            raise PlayerKilled('Burned')
            
    def drown(self, game_engine, pos_x, pos_y):
        if not self.is_safe('WATER', 'INV_FLIPPERS'):
            #kill the unit
            raise PlayerKilled('Drowned')

    def step_on_item(self, target_item):
        if (target_item instanceof Monster):
            raise PlayerKilled("player stepped on monster")
        return None

    def add_to_sliplist(self, game_engine, index, pos_x, pos_y, dx, dy):
        """
        if index is None, add to the list
        """
        self.is_slipping = True
        #unshift is like insert(0, item)
        game_engine.slip_list.unshift((pos_x, pos_y, dx, dy))

    def kill(self, msg):
        raise PlayerKilled(msg)


class Monster(Creature):
    """
    #Monsters
    #64    Bug (N)                             1    0
    #65    Bug (W)                             1    0
    #66    Bug (S)                             1    0
    #67    Bug (E)                             1    0
    #68    Fire Bug (N)                        1    0
    #69    Fire Bug (W)                        1    0
    #70    Fire Bug (S)                        1    0
    #71    Fire Bug (E)                        1    0
    #72    Pink Ball (N)                       1    0
    #73    Pink Ball (W)                       1    0
    #74    Pink Ball (S)                       1    0
    #75    Pink Ball (E)                       1    0
    #76    Tank (N)                            1    0
    #77    Tank (W)                            1    0
    #78    Tank (S)                            1    0
    #79    Tank (E)                            1    0
    #80    Ghost (N)                           1    0
    #81    Ghost (W)                           1    0
    #82    Ghost (S)                           1    0
    #83    Ghost (E)                           1    0
    #84    Frog (N)                            1    0
    #85    Frog (W)                            1    0
    #86    Frog (S)                            1    0
    #87    Frog (E)                            1    0
    #88    Dumbbell (N)                        1    0
    #89    Dumbbell (W)                        1    0
    #90    Dumbbell (S)                        1    0
    #91    Dumbbell (E)                        1    0
    #92    Blob (N)                            1    0
    #93    Blob (W)                            1    0
    #94    Blob (S)                            1    0
    #95    Blob (E)                            1    0
    #96    Centipede (N)                       1    0
    #97    Centipede (W)                       1    0
    #98    Centipede (S)                       1    0
    #99    Centipede (E)                       1    0
    """
    def __init__(self):
        #TODO: Remove collision_list
        self.collision_list = [Creature]
        self.unenterable = [Dirt, Gravel]
        self.avoid_list = [Block]

    def valid_move(self, start_x, start_y, dx, dy, map, items, game_engine, slip_ind):
        valid_move, new_x, new_y = Item.valid_move(self, start_x, start_y, dx, dy, map, items, game_engine, slip_ind)
        if valid_move:
            game_engine.creature_links[self.creature_link] = new_x, new_y
        return valid_move, new_x, new_y


    def move(self, start_x, start_y, game_engine):
        if self.is_slipping:
            return start_x, start_y
        map = game_engine.map
        items = game_engine.items
        turn_dict_current = TURN_DICT[self.dir]
        for turn_dir in self.turn_priority:
            #map the turn direction to a absolute direction
            abs_turn_dir = turn_dict_current[turn_dir]
            dx, dy = DIRDXY[abs_turn_dir]
            is_valid, new_x, new_y = self.valid_move(start_x, start_y, dx, dy, map, items, game_engine, None)
            if is_valid:
                self.set_new_dir(abs_turn_dir)
                return new_x, new_y
        return start_x, start_y

    def kill(self, msg):
        raise MonsterKilled(msg)


class Bug(Monster):
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img
        self.avoid_list = [Block, Dirt, Gravel, Bug]

        #Make this better (maybe a constant?)
        self.dir_map = {
            'N': 64,
            'W': 65,
            'S': 66,
            'E': 67
        }
        self.image_set = images

        dir = None
        #TODO: Something more backwards compatible
        for key in Object.keys(self.dir_map):
            if self.dir_map[key] == type_index:
                dir = key
                break
        self.set_new_dir(dir)
        self.turn_priority = ['L', 'F', 'R', 'B']

    def step_on_item(self, target_item):
        if (target_item instanceof Player):
            return "bug ate player"
        return None

    def set_new_dir(self, dir):
        type_index = self.dir_map[dir]
        self.dir = dir
        self.img = self.image_set[type_index]


class FireBug(Monster):
    def __init__(self, type_index, images, bg_img):
        self.immunities = ['FIRE']
        self.bg_img = bg_img

        #Make this better (maybe a constant?)
        self.dir_map = {
            'N': 68,
            'W': 69,
            'S': 70,
            'E': 71
        }
        self.image_set = images

        dir = None
        #TODO: Something more backwards compatible
        for key in Object.keys(self.dir_map):
            if self.dir_map[key] == type_index:
                dir = key
                break
        self.set_new_dir(dir)
        self.turn_priority = ['F', 'L', 'R', 'B']

    def step_on_item(self, target_item):
        if (target_item instanceof Player):
            return "fireball burned player"
        return None

    def set_new_dir(self, dir):
        type_index = self.dir_map[dir]
        self.dir = dir
        self.img = self.image_set[type_index]


class PinkBall(Monster):
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img

        #Make this better (maybe a constant?)
        self.dir_map = {
            'N': 72,
            'W': 73,
            'S': 74,
            'E': 75
        }
        self.image_set = images

        dir = None
        #TODO: Something more backwards compatible
        for key in Object.keys(self.dir_map):
            if self.dir_map[key] == type_index:
                dir = key
                break
        self.set_new_dir(dir)
        self.turn_priority = ['F', 'B']

    def step_on_item(self, target_item):
        if (target_item instanceof Player):
            return "fireball burned player"
        return None

    def set_new_dir(self, dir):
        type_index = self.dir_map[dir]
        self.dir = dir
        self.img = self.image_set[type_index]


class Tank(Monster):
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img

        #Make this better (maybe a constant?)
        self.dir_map = {
            'N': 76,
            'W': 77,
            'S': 78,
            'E': 79
        }
        self.image_set = images

        self.state = 0 #0=still, 1=turning, 2=moving

        dir = None
        #TODO: Something more backwards compatible
        for key in Object.keys(self.dir_map):
            if self.dir_map[key] == type_index:
                dir = key
                break
        self.set_new_dir(dir)
        self.fin_dir = None
        self.clicked = False

    def step_on_item(self, target_item):
        if (target_item instanceof Player):
            return "tank crushed player"
        return None

    def set_new_dir(self, dir):
        type_index = self.dir_map[dir]
        self.dir = dir
        self.img = self.image_set[type_index]

    def trigger(self):
        #turn the object instantly
        new_dir = TURN_DICT[self.dir]['L']
        fin_dir = TURN_DICT[new_dir]['L']
        self.set_new_dir(new_dir)
        self.fin_dir = fin_dir
        self.clicked = True

    def move(self, start_x, start_y, game_engine):
        if not self.clicked:
            return start_x, start_y

        if self.new_dir != self.fin_dir:
            self.set_new_dir(self.fin_dir)
        #try to move
        dx, dy = DIRDXY[self.fin_dir]
        map = game_engine.map
        items = game_engine.items
        is_valid, new_x, new_y = self.valid_move(start_x, start_y, dx, dy, map, items, game_engine, None)
        if is_valid:
            return new_x, new_y
        else:
            self.clicked = False
            return start_x, start_y


class Ghost(Monster):
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img

        #Make this better (maybe a constant?)
        self.dir_map = {
            'N': 80,
            'W': 81,
            'S': 82,
            'E': 83
        }
        self.image_set = images

        dir = None
        #TODO: Something more backwards compatible
        for key in Object.keys(self.dir_map):
            if self.dir_map[key] == type_index:
                dir = key
                break
        self.set_new_dir(dir)
        self.turn_priority = ['F', 'L', 'R', 'B']

    def step_on_item(self, target_item):
        if (target_item instanceof Player):
            return "fireball burned player"
        return None

    def set_new_dir(self, dir):
        type_index = self.dir_map[dir]
        self.dir = dir
        self.img = self.image_set[type_index]


class Frog(Monster):
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img
        self.img = images[type_index]

class Walker(Monster):
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img
        self.img = images[type_index]

class Blob(Monster):
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img
        self.img = images[type_index]

class Centipede(Monster):
    def __init__(self, type_index, images, bg_img):
        self.bg_img = bg_img
        #Make this better (maybe a constant?)
        self.dir_map = {
            98: 'N',
            97: 'W',
            98: 'S',
            99: 'E'
        }
        self.type_index = type_index
        self.image_set = images
        self.set_image()

    def set_image(self):
        self.img = self.image_set[self.type_index]

    def move(start_x, start_y):
        self.valid_move(start_x, start_y, dx, dy, map, items, game_engine, slip_ind)
        pass
