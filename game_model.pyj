#   Copyright 2012 Charles Law (charles.law@gmail.com)
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

import model_objects
import item_objects

direction_dpos_dict = {'UP':    [ 0, -1], 'DOWN':  [ 0,  1], 'LEFT':  [-1,  0], 'RIGHT': [ 1,  0]}


FRAMES_PER_SLIDE = 2 #20 f/s / 10m/s = 2 frames
FRAMES_PER_REG = 4 #20 f/s / 5m/s = 4 frames
BLOCK_DIM = 48 #pixels per block
NUM_BLOCKS = 9 #Number of blocks on the screen
PLAYERPOS = 4 #(Num_blocks-1)/2
LEVELSIZE = 32 #LEVEL PARAMETERS

PLAYER_TYPE = 1
MONSTER_TYPE = 2


LEVEL_RUNNING = 0
DEAD = 1
FINISHED = 2


conversion_map = [Tile, Wall, Chip, Water, Fire, HiddenWall, BlockedNorth, \
    BlockedWest, BlockedSouth, BlockedEast, Block, Dirt, Ice, ForceSouth, \
    CloneNorth, CloneWest, CloneSouth, CloneEast, ForceNorth, ForceEast, \
    ForstWest, Exit, DoorBlue, DoorRed, DoorGreen, DoorYellow, IceSE, \
    IceSW, IceNW, IceNE, BlueNone, BlueWall, None, Theif, Socket, \
    ButtonGreen, ButtonRed, SwitchedWall, SwitchedWall, ButtonBrown, \
    ButtonBlue, Teleport, Bomb, Trap, SemiHiddenWall, Gravel, PassWall, \
    Hint, BlockedSE, Cloner, ForceAll, Player, Player, Player, None, None, \
    None, Player, Exit, Exit, Player, Player, Player, Player, Bug, Bug, Bug, \
    Bug, FireBug, FireBug, FireBug, FireBug, PinkBall, PinkBall, PinkBall, \
    PinkBall, Tank, Tank, Tank, Tank, Ghost, Ghost, Ghost, Ghost, Frog, Frog, \
    Frog, Frog, Walker, Walker, Walker, Walker, Blob, Blob, Blob, Blob, \
    Centipede, Centipede, Centipede, Centipede, KeyBlue, KeyRed, KeyGreen, \
    KeyYellow, Flippers, FireBoots, Skates, SuctionBoots, Player, Player, \
    Player, Player]
    

image_map = ['tile1.png', 'tile2.png', 'cyb002.png', 'cyb003.png', 'cyb004.png',
    'tile1.png', 'BlockedNorth', \
    'BlockedWest', 'BlockedSouth', 'BlockedEast', \
    'box.png', 'cyb011.png', 'cyb012.png', 'slideD.png', \
    'CloneNorth', 'CloneWest', 'CloneSouth', 'CloneEast', 'slideU.png', 'slideR.png', \
    'slideL.png', 'exit.png', 'cyb022.png', 'cyb023.png', 'cyb024.png', 'cyb025.png', 'cyb026.png', \
    'cyb027.png', 'cyb028.png', 'cyb029.png', 'twi030.png', 'twi030.png', 'None', 'twi033.gif', 'twi034.gif', \
    'twi035.gif', 'twi036.gif', 'twi037.gif', 'twi038.gif', 'twi039.gif', \
    'twi040.gif', 'twi041.gif', 'twi042.gif', 'twi043.gif', 'tile1.png', 'twi045.gif', 'PassWall', \
    'twi047.gif', 'BlockedSE', 'twi049.gif', 'ForceAll', 'borg2.png', 'borg2.png', 'borg2.png', 'None', 'None', \
    'None', 'Player', 'exit.png', 'exit.png', 'borg2.png', 'borg2.png', 'borg2.png', 'borg2.png', 'twi064.gif', \
    'twi065.gif', 'twi066.gif', 'twi067.gif', 'twi068.gif', 'twi069.gif', \
    'twi070.gif', 'twi071.gif', 'twi072.gif', 'twi073.gif', 'twi074.gif', \
    'twi075.gif', 'twi076.gif', 'twi077.gif', 'twi078.gif', 'twi079.gif', \
    'twi080.gif', 'twi081.gif', 'twi082.gif', 'twi083.gif', 'Frog', 'Frog', \
    'Frog', 'Frog', 'Walker', 'Walker', 'Walker', 'Walker', 'Blob', 'Blob', 'Blob', 'Blob', \
    'Centipede', 'Centipede', 'Centipede', 'Centipede', 'twi100.gif', 'twi101.gif', 'twi102.gif', \
    'twi103.gif', 'twi104.gif', 'twi105.gif', 'twi106.gif', 'twi107.gif', 'borg2.png', 'borg2.png', \
    'borg2.png', 'borg2.png']
    
bg_image = [None, None, None, None, None,
    None, None, \
    None, None, None, \
    None, None, None, None, \
    None, None, None, None, None, None, \
    None, None, None, None, None, None, None, \
    None, None, None, None, None, None, None, None, \
    0, None, None, None, None, \
    0, None, None, None, None, None, None, \
    None, None, None, None, None, None, None, None, None, \
    None, None, None, None, None, None, None, None, None, None, None, \
    None, None, None, None, None, None, None, None, \
    None, None, None, None, None, None, None, None, None, None, None, \
    None, None, None, None, None, None, None, None, None, None, \
    None, None, None, None, 0, 0, 0, \
    0, 0, 0, 0, 0, None, None, \
    None, None]    


def object_generator(index, loaded_images):
    object_class = conversion_map[index]
    if bg_image[index] != None:
        bg_img = loaded_images[bg_image[index]]
    else:
        bg_img = None
    
    return new object_class(index, loaded_images, bg_img)


def enum_is_item(itemEnum):
    if itemEnum==10:
        return True
    elif itemEnum>59 and itemEnum<100:
        return True
    elif itemEnum>107 and itemEnum<111:
        return True
    else:
        return False

def enum_is_monster(itemEnum):
    if itemEnum>63 and itemEnum<100:
        return True
    return False


def randfloat(min, max):
    return Math.random() * (max - min) + min


def randint(min, max):
    return Math.floor(Math.random() * (max - min + 1)) + min


class Cyborg:
    def __init__(self, canvas):
        self.canvas = canvas
        

    def start_level(self, controller, start_pos, map, items, level_info, images, links, creature_links, trap_controls, clone_controles):
        self.controller = controller
        self.x = start_pos[0]
        self.y = start_pos[1]
        self.map = map
        self.items = items
        self.images = images
        self.num_chips = level_info[1]
        self.chips_left = level_info[1]
        self.game_state = LEVEL_RUNNING
        self.links = links
        self.creature_links = creature_links
        trap_controls = trap_controls
        clone_controles = clone_controles
        self.slip_list = []

        self._set_creature_links()
        
        #setup controls
        for but_x, but_y, trap_x, trap_y in trap_controls:
            self.map[but_x][but_y].set_trap(trap_x, trap_y)
        for but_x, but_y, trap_x, trap_y in clone_controles:
            self.map[but_x][but_y].set_trap(trap_x, trap_y)
        
        player_item = self.items[self.x][self.y]
        inv_items = ['key_red', 'key_green']
        for inv_item in inv_items:
            player_item.set_inventory_icon(inv_item, undefined)


    def _set_creature_links(self):
        """
        Goes through the creature link list and set on the monster
        """
        for i in range(len(self.creature_links)):
            pos_x, pos_y = self.creature_links[i]
            self.items[pos_x][pos_y].creature_link = i


    def move_monsters(self):
        for i in range(len(self.creature_links)-1, -1, -1):
            pos_x, pos_y = self.creature_links[i]
            try:
                new_x, new_y = self.items[pos_x][pos_y].move(pos_x, pos_y, self)
            except MonsterKilled as exc:
                #TODO: What if a monster kills another?  is that possible
                self.creature_links.splice(i, 1)
                self._set_creature_links()

    def switch_green_doors(self):
        for pos_x, pos_y in self.links['GREEN_BUTTON']:
            self.map[pos_x][pos_y].flip_wall()

    def turn_tanks(self):
        for i in range(len(self.creature_links)):
            pos_x, pos_y = self.creature_links[i]
            self.items[pos_x][pos_y]
            if self.items[pos_x][pos_y] instanceof Tank:
                self.items[pos_x][pos_y].trigger()
                
    
    def get_next_teleport(self, pos_x, pos_y):
        #get the ind of the current teleport
        ind = -1
        for i in range(len(self.links['TELEPORTS'])):
            tel_x, tel_y = self.links['TELEPORTS'][i]
            if tel_x == pos_x and tel_y == pos_y:
                ind = i
                break
        
        if ind < 0:
            return None, None
        else:
            if ind == 0:
                pre_ind = len(self.links['TELEPORTS']) - 1
            else:
                pre_ind = ind - 1
            
            return self.links['TELEPORTS'][pre_ind]
        

    def have_all_chips(self):
        if self.chips_left > 0:
            return False
        else:
            return True

    def get_chip(self):
        self.chips_left -= 1


    def calculate_move(self, start_x, start_y, dx, dy):
        """
        Try to move in the item in start_x, start_y by dx, dy
        Return the actual move
        """
        pass


    def move_player(self, direction):
        dx, dy = direction_dpos_dict[direction]
        player_item = self.items[self.x][self.y]

        #This might raise a PlayerKilled Exception
        player_item.valid_move(self.x, self.y, dx, dy, self.map, self.items, self, None)
        
        if self.game_state == FINISHED:
            self.controller.new_level(True)

    def get_slip_ind(self, start_x, start_y):
        for i in range(len(self.slip_list)):
            slip_x, slip_y, slip_dx, slip_dy = self.slip_list[i]
            if slip_x == start_x and slip_y == start_y:
                #found the item, return it
                return i
                break
        return -1
                
    def run_slips(self):
        #slip the player
        i = 0
        more_items_to_slip = i < len(self.slip_list)

        while more_items_to_slip:
            #get the item
            pos_x, pos_y, dx, dy = self.slip_list[i]
            slip_item = self.items[pos_x][pos_y]
            
            #try to slip the item
            #console.log('SLIP_ITEM' + pos_x + ' ' + pos_y + ' ' + i + ' ' + dx + ' ' + dy)
            console.log('1 '+JSON.stringify(self.slip_list))
            valid_move, new_x, new_y = slip_item.valid_move(pos_x, pos_y, dx, dy, self.map,
                                                            self.items, self, i)
            console.log('2 '+JSON.stringify(self.slip_list))
        
            #go to the next item in the list
            i += 1
            more_items_to_slip = i < len(self.slip_list)
            #console.log('END ITER' + self.slip_list)


    def update(self):
        # Make model updates
        self.draw()


    def draw(self):
         self.refresh()

        
    def refresh(self):
        startX = Math.min( Math.max(0,self.x-PLAYERPOS), LEVELSIZE-NUM_BLOCKS)
        startY = Math.min( Math.max(0,self.y-PLAYERPOS), LEVELSIZE-NUM_BLOCKS)
        ctx = self.canvas.getContext('2d')
        ctx.save()
        
        dispx = 0
        for map_x in range(startX, startX+NUM_BLOCKS):
            dispy = 0
            for map_y in range(startY, startY+NUM_BLOCKS):
                #draw the map first
                if self.map[map_x][map_y]:
                    self.map[map_x][map_y].draw(ctx, dispx, dispy)
                if self.items[map_x][map_y]:
                    self.items[map_x][map_y].draw(ctx, dispx, dispy)
                dispy += BLOCK_DIM
            
            dispx += BLOCK_DIM
        ctx.restore()

